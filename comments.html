
<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>WhoWatch コメント（最新が上＋弾幕）</title>
<style>
  html,body{
    margin:0; padding:0; width:100vw; height:100vh;
    background:transparent; color:#fff; font-family:sans-serif;
  }
  /* 左端のパネル：横30% × 縦80%、背景透明、スクロールバー非表示 */
  #panel{
    position:fixed; left:0; top:10vh; width:30vw; height:80vh;
    box-sizing:border-box; padding:10px 12px;
    background:transparent; border:none;
    overflow-y:auto; scrollbar-width:none; -ms-overflow-style:none;
  }
  #panel::-webkit-scrollbar{ width:0; height:0 }
  #title, #status{ display:none; } /* 見出し/ステータスは非表示 */

  /* コメント表示（最新が上＝先頭に追加） */
  ul#list{ list-style:none; padding:0; margin:0 }
  ul#list li{
    margin:8px 0; padding:8px 10px;
    background:rgba(0,0,0,.3);
    border-left:4px solid #ffeb66; border-radius:10px;
  }
  .user{ font-weight:700; font-size:38px; }
  .msg{ white-space:pre-wrap; word-break:break-word; font-size:40px; }
  .meta{ font-size:20px; opacity:.7; margin-top:4px; }
  .msg img.emoji{ vertical-align:text-bottom; width:1.5em; height:1.5em; } /* 絵文字用 */

  #err{ display:none; } /* エラーは画面には出さない（コンソールで確認） */
</style>
</head>
<body>
<div id="panel">
  <div id="title">最新コメント（上＝最新）</div>
  <div id="status">初期化中…</div>
  <div id="err"></div>
  <ul id="list"></ul>
</div>

  
<!-- 先にGSAPを読み込む（defer：記述順で実行される） -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js" defer></script>

<script>
/* ====== 設定（あなたの値）====== */
const USER        = "rarirure69n66";
const GISTID      = "5697ca0fe833531c03c10ba6950f7d3e";
const POLL_MS     = 1500; // 1.5秒ごと
const WORKER_BASE = "https://whowatch-relay.win3100c.workers.dev/ww/lives/"; // 末尾 / 必須
/* ================================== */

const RAW_GIST = `https://gist.githubusercontent.com/${USER}/${GISTID}/raw/current.txt`;
const API_GIST = `https://api.github.com/gists/${GISTID}`;

const elList = document.getElementById('list');

/* ---------- 弾幕（右→左に流す：messageだけ） ---------- */
let dmCount = 0;
const laneHeight = 36;    // 1行の高さ
const lanePadding = 6;    // 行間
const lanesInUse = new Set();
function pickFreeLane(aroundY = window.innerHeight/2){
  const total = Math.max(1, Math.floor(window.innerHeight / (laneHeight + lanePadding)));
  const centerIdx = Math.max(0, Math.min(total-1, Math.floor(aroundY / (laneHeight + lanePadding))));
  const order = [];
  for (let d=0; d<total; d++){
    if (centerIdx - d >= 0) order.push(centerIdx - d);
    if (centerIdx + d < total) order.push(centerIdx + d);
  }
  for (const idx of order){
    if (!lanesInUse.has(idx)) { lanesInUse.add(idx); return { idx, top: idx*(laneHeight+lanePadding)+10 }; }
  }
  const fallback = total-1;
  lanesInUse.add(fallback);
  return { idx:fallback, top:fallback*(laneHeight+lanePadding)+10 };
}

async function flowMessage(messageText, aroundY){
  if (!messageText) return;
  const div = document.createElement('div');
  const id = "dm" + (dmCount++);
  div.id = id;
  div.style.position='fixed'; div.style.zIndex='5'; div.style.whiteSpace='nowrap';
  div.style.pointerEvents='none'; div.style.fontWeight='700';
  div.style.textShadow='0 2px 4px rgba(0,0,0,.7)';
  div.style.fontSize='28px'; div.style.color='#fff';
  div.style.left = document.documentElement.clientWidth + 'px';
  const lane = pickFreeLane(aroundY ?? window.innerHeight/2);
  div.style.top = lane.top + 'px';
  div.appendChild(document.createTextNode(String(messageText)));
  document.body.appendChild(div);
  const distance = document.documentElement.clientWidth + div.clientWidth + 20;
  const duration = 7; // 秒
  try{
    await gsap.to("#"+id, { duration, x:-distance, ease:"none" });
  }finally{
    lanesInUse.delete(lane.idx);
    div.remove();
  }
}

/* ---------- サニタイザ（限定的にHTML許可：IMG/A/BRなど） ---------- */
function sanitizeMessageHTML(raw){
  if (!/[<>&]/.test(raw)) return document.createTextNode(raw);
  const parser = new DOMParser();
  const doc = parser.parseFromString(`<div>${raw}</div>`, "text/html");
  const root = doc.body.firstChild;

  const allowedTags = new Set(["BR","IMG","B","I","U","STRONG","EM","A","SPAN"]);
  const allowedImgHostSuffix = [".whowatch.tv"];
  const frag = document.createDocumentFragment();

  function isAllowedImgSrc(urlStr){
    try{
      const u = new URL(urlStr, location.href);
      if (u.protocol !== "https:") return false;
      return allowedImgHostSuffix.some(suf => u.hostname.endsWith(suf));
    }catch{ return false; }
  }
  function walk(node, outParent){
    if (node.nodeType === Node.TEXT_NODE){ outParent.appendChild(document.createTextNode(node.nodeValue)); return; }
    if (node.nodeType !== Node.ELEMENT_NODE) return;

    const tag = node.tagName;
    if (!allowedTags.has(tag)){
      for (const child of [...node.childNodes]) walk(child, outParent);
      return;
    }
    if (tag === "BR"){ outParent.appendChild(document.createElement("br")); return; }
    if (tag === "IMG"){
      const src = node.getAttribute("src") || "";
      if (!isAllowedImgSrc(src)){ outParent.appendChild(document.createTextNode("[img blocked]")); return; }
      const img = document.createElement("img");
      img.src = src;
      if (src.includes("/emoji/")) img.className = "emoji";
      img.referrerPolicy = "no-referrer"; img.loading = "lazy";
      outParent.appendChild(img);
      return;
    }
    if (tag === "A"){
      const href = node.getAttribute("href") || "";
      try{
        const u = new URL(href, location.href);
        if (u.protocol !== "https:") throw 0;
        const a = document.createElement("a");
        a.href = u.href; a.target="_blank"; a.rel="noopener noreferrer";
        for (const child of [...node.childNodes]) walk(child, a);
        outParent.appendChild(a);
      }catch{
        for (const child of [...node.childNodes]) walk(child, outParent);
      }
      return;
    }
    const safe = document.createElement(tag.toLowerCase());
    for (const child of [...node.childNodes]) walk(child, safe);
    outParent.appendChild(safe);
  }
  for (const child of [...root.childNodes]) walk(child, frag);
  return frag;
}

/* ---------- Gistから元URLを取得 ---------- */
async function readGistText(){
  try{
    const res = await fetch(API_GIST, { headers:{ "Accept":"application/vnd.github+json" }, cache:"no-store" });
    if(!res.ok) throw new Error(`Gist API ${res.status}`);
    const j = await res.json();
    const f = j.files?.["current.txt"];
    if (!f) throw new Error("Gistに current.txt がありません");
    if (f.truncated === false && typeof f.content === "string") return f.content.trim();
    if (f.raw_url){
      const r = await fetch(f.raw_url + "?t=" + Date.now(), { cache:"no-store" });
      if(!r.ok) throw new Error(`Gist RAW ${r.status}`);
      return (await r.text()).trim();
    }
    throw new Error("Gistファイルを読めません（raw_urlなし）");
  }catch(e){
    const r = await fetch(RAW_GIST + "?t=" + Date.now(), { cache:"no-store" });
    if(!r.ok) throw new Error(`Gist RAW ${r.status} / ${e.message}`);
    return (await r.text()).trim();
  }
}

/* ---------- URL→id抽出＆プロキシURL生成 ---------- */
function buildApiUrlFromSource(u){
  const s=(u||"").trim();
  let m = s.match(/^https?:\/\/api\.whowatch\.tv\/lives\/(\d+)/);
  if(!m) m = s.match(/whowatch\.tv\/(?:lives|viewer)\/(\d+)/);
  if(!m) m = s.match(/r\.whowatch\.tv\/lives\/(\d+)/);
  if(!m) return null;
  const id = m[1];
  return { id, url: `${WORKER_BASE}${id}?last_updated_at=` };
}

/* ---------- 表示（最新を上：先頭に追加） ---------- */
function prependComment(c){
  const li   = document.createElement('li');
  const user = c?.user?.name ?? c?.user_name ?? "匿名";
  const msg  = c?.message ?? c?.escaped_message ?? c?.text ?? c?.body ?? "";
  const ts   = typeof c?.posted_at === "number"
                ? new Date(c.posted_at).toLocaleString()
                : (c?.created_at || c?.updated_at || c?.time || "");

  const userDiv = document.createElement('div'); userDiv.className = "user"; userDiv.textContent = user;
  const msgDiv  = document.createElement('div'); msgDiv.className  = "msg";
  msgDiv.appendChild(sanitizeMessageHTML(msg));
  const metaDiv = document.createElement('div'); metaDiv.className = "meta"; metaDiv.textContent = ts;

  li.appendChild(userDiv); li.appendChild(msgDiv); li.appendChild(metaDiv);
  
    // --- ★ アイテム画像（play_item_pattern.image_url）を表示 ---
  const itemImgUrl =
    c?.play_item_pattern?.image_url ||
    c?.play_item?.image_url ||
    null;

  const itemCount = Number(c?.item_count || 0);

  if (itemImgUrl) {
    const itemRow  = document.createElement('div');
    itemRow.className = 'item';

    const wrap = document.createElement('span');
    wrap.className = 'item-img-wrap';

    const img = new Image();
    img.src = itemImgUrl;
    img.className = 'item-img';
    img.referrerPolicy = 'no-referrer';
    img.loading = 'lazy';

    wrap.appendChild(img);

    // 個数が 2 以上ならバッジ表示
    if (itemCount >= 2) {
      const badge = document.createElement('span');
      badge.className = 'item-count';
      badge.textContent = 'x' + itemCount;
      wrap.appendChild(badge);
    }

    itemRow.appendChild(wrap);

    // 画像の横に「message」（テキスト）も並べたい場合は下を有効化
    // const cap = document.createElement('span');
    // cap.textContent = ' ' + (c?.message ?? '');
    // itemRow.appendChild(cap);

    li.appendChild(itemRow);
  }



  elList.insertBefore(li, elList.firstChild); // 先頭に追加＝最新が上

  // 件数制限（古い方＝末尾から削除）
  const MAX = 80;
  while (elList.childElementCount > MAX) elList.removeChild(elList.lastChild);
}

/* ---------- 取得・増分（last_updated_at = UNIXミリ秒） ---------- */
let apiUrl = "", liveId = "";
let lastCurMs = null;   // 常にUNIXミリ秒
let etag   = null;      // 相性悪ければ無効化OK
let seen   = new Set(); // 重複排除

function idOf(c){
  return c?.id ?? `${c?.user?.id||c?.user_id||"u"}-${c?.posted_at||c?.created_at||c?.updated_at||Math.random()}`;
}
function tsMs(c){
  if (typeof c?.posted_at === "number") return c.posted_at;
  const t = c?.created_at || c?.updated_at || c?.time;
  const ms = Date.parse(t);
  return Number.isNaN(ms) ? 0 : ms;
}

async function init(){
  const txt = await readGistText();
  const first = (txt.split(/\r?\n/).map(s=>s.trim()).find(Boolean)) || "";
  const built = buildApiUrlFromSource(first);
  if (!built) throw new Error("対応外URL: " + first);
  apiUrl = built.url; liveId = built.id; lastCurMs = null; // 全取得スタート
}

async function pollOnce(){
  const url = apiUrl + encodeURIComponent(lastCurMs != null ? String(lastCurMs) : "");
  const headers = {"cache-control":"no-store"};
  if (etag) headers["If-None-Match"] = etag; // 問題あればこの行と下のetag代入をコメントアウト

  const res = await fetch(url, { headers });
  if (res.status === 304) return;
  if (!res.ok) throw new Error(`WhoWatch ${res.status}`);

  etag = res.headers.get("etag") || etag;
  const json = await res.json();

  // コメント配列を検出
  let arr = Array.isArray(json.comments) ? json.comments
          : Array.isArray(json.data)     ? json.data
          : null;
  if (!arr){
    const find = (obj, depth=0) => {
      if(depth>3 || !obj) return null;
      if(Array.isArray(obj)){
        const score = obj.slice(0,5).reduce((n,it)=> n + (it && (it.message||it.text||it.body) ? 1:0), 0);
        return score>=2 ? obj : null;
      }
      if(typeof obj === "object"){
        for(const k of Object.keys(obj)){ const f=find(obj[k], depth+1); if(f) return f; }
      }
      return null;
    };
    arr = find(json);
  }
  if (!Array.isArray(arr) || !arr.length) return;

  // 古→新に並べて、新着だけ処理
  arr.sort((a,b)=> tsMs(a) - tsMs(b));

  const newly = [];
  for (const c of arr){
    const id = idOf(c);
    if (seen.has(id)) continue;
    seen.add(id);
    newly.push(c);
  }

  // 画面パネル（最新上）に追加
  for (const c of newly){ prependComment(c); }

  // 弾幕（messageだけ）を右→左に流す
  //for (const c of newly){
    //const msgOnly = c?.message ?? "";
    //if (msgOnly) flowMessage(msgOnly);
  //}

  // カーソル更新（サーバ返却を優先→無ければ最後のコメント時刻）
  let nextCurMs = null;
  if (json.last_updated_at != null){
    const n = Number(json.last_updated_at);
    if (!Number.isNaN(n)) nextCurMs = n;
  }
  if (nextCurMs == null && arr.length){
    nextCurMs = tsMs(arr[arr.length - 1]);
  }
  if (nextCurMs != null) lastCurMs = nextCurMs - 1; // 取りこぼし防止で1ms引く
}

async function loop(){
  while(true){
    try{ await pollOnce(); } catch(e){ console.error(e); }
    await new Promise(r=>setTimeout(r, POLL_MS));
  }
}

(async function main(){
  try{
    await init();
    await pollOnce();
    loop();
  }catch(e){
    console.error("init error:", e);
  }
})();
</script>
</body>
</html>



