<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0" />
<title>WhoWatch コメント（最新が上／左30%×縦80%／安全IMG）</title>
<style>
  html,body{
    margin: 0;
    padding: 0;
    width: 100vw;
    height: 100vh;
    background:transparent; /* ←透明に変更 */
    color:#fff;
    font-family:sans-serif;
    height:100%;
  }
  
  #panel{
    position:fixed; left:0; top:10vh;
    width:30vw; height:80vh;
    box-sizing:border-box; padding:10px 12px;
    background:transparent; /* ←透明に変更 */
    border-right:none;
    overflow-y:auto;
    scrollbar-width:none; -ms-overflow-style:none;
  }
  #panel::-webkit-scrollbar{ width:0; height:0 }

  /* ヘッダー/ステータスは非表示（必要なら表示可） */
  #title, #status{ display:none; }

  /* コメントリスト（最新を上＝先頭に追加） */
  ul#list{list-style:none; padding:0; margin:0}
  ul#list li{
    margin:8px 0; padding:8px 10px;
    background:rgba(0,0,0,.6);
    border-left:4px solid #ffeb66; border-radius:10px;
  }

  .msg{
    white-space:pre-wrap;
    word-break:break-word;
    font-size: 30px; /* ←本文だけ別で調整可能 */
  }
  .user{
    font-weight:700;
    font-size: 26px; /* ←ユーザー名のサイズ */
  }
  
  .meta{
    font-size: 20px; /* ←日時や付帯情報のサイズ */
    opacity:.7;
    margin-top:4px;
  }
  /* 絵文字画像の統一スタイル（style属性は捨てるのでCSSで指定） */
  .msg img.emoji{ vertical-align:text-bottom; width:1.5em; height:1.5em; }

  /* エラー表示は隠す（必要時だけ開発者ツールで確認） */
  #err{display:none;}
</style>
</head>
<body>
<div id="panel">
  <div id="title">最新コメント（上＝最新）</div>
  <div id="status">初期化中…</div>
  <div id="err"></div>
  <ul id="list"></ul>
</div>

<script>
/* ====== 設定（あなたの値）====== */
const USER        = "rarirure69n66";
const GISTID      = "5697ca0fe833531c03c10ba6950f7d3e";
const POLL_MS     = 1500; // 1.5秒ごと
const WORKER_BASE = "https://whowatch-relay.win3100c.workers.dev/ww/lives/"; // 末尾 / 必須
/* ================================== */

const RAW_GIST = `https://gist.githubusercontent.com/${USER}/${GISTID}/raw/current.txt`;
const API_GIST = `https://api.github.com/gists/${GISTID}`;

const elList = document.getElementById('list');
const elErr  = document.getElementById('err');

function escapeHtml(s){ return String(s).replace(/[&<>"]/g, c=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;' }[c])); }

/* ---------- 安全サニタイザ（限定的にHTML許可） ---------- */
function sanitizeMessageHTML(raw){
  if (!/[<>&]/.test(raw)) return document.createTextNode(raw);
  const parser = new DOMParser();
  const doc = parser.parseFromString(`<div>${raw}</div>`, "text/html");
  const root = doc.body.firstChild;

  const allowedTags = new Set(["BR","IMG","B","I","U","STRONG","EM","A","SPAN"]);
  const allowedImgHostSuffix = [".whowatch.tv"]; // img.whowatch.tv 等
  const frag = document.createDocumentFragment();

  function isAllowedImgSrc(urlStr){
    try{
      const u = new URL(urlStr, location.href);
      if (u.protocol !== "https:") return false;
      return allowedImgHostSuffix.some(suf => u.hostname.endsWith(suf));
    }catch{ return false; }
  }
  function walk(node, outParent){
    if (node.nodeType === Node.TEXT_NODE){
      outParent.appendChild(document.createTextNode(node.nodeValue));
      return;
    }
    if (node.nodeType !== Node.ELEMENT_NODE) return;

    const tag = node.tagName;
    if (!allowedTags.has(tag)){
      for (const child of [...node.childNodes]) walk(child, outParent);
      return;
    }
    if (tag === "BR"){ outParent.appendChild(document.createElement("br")); return; }
    if (tag === "IMG"){
      const src = node.getAttribute("src") || "";
      if (!isAllowedImgSrc(src)){
        outParent.appendChild(document.createTextNode("[img blocked]"));
        return;
      }
      const img = document.createElement("img");
      img.src = src;
      if (src.includes("/emoji/")) img.className = "emoji";
      img.referrerPolicy = "no-referrer";
      img.loading = "lazy";
      outParent.appendChild(img);
      return;
    }
    if (tag === "A"){
      const href = node.getAttribute("href") || "";
      try{
        const u = new URL(href, location.href);
        if (u.protocol !== "https:") throw 0;
        const a = document.createElement("a");
        a.href = u.href; a.target = "_blank"; a.rel = "noopener noreferrer";
        for (const child of [...node.childNodes]) walk(child, a);
        outParent.appendChild(a);
      }catch{
        for (const child of [...node.childNodes]) walk(child, outParent);
      }
      return;
    }
    // B/I/U/STRONG/EM/SPAN は属性無しでそのまま許可
    const safe = document.createElement(tag.toLowerCase());
    for (const child of [...node.childNodes]) walk(child, safe);
    outParent.appendChild(safe);
  }
  for (const child of [...root.childNodes]) walk(child, frag);
  return frag;
}

/* ---------- Gist からURLを取得 ---------- */
async function readGistText(){
  try{
    const res = await fetch(API_GIST, { headers: { "Accept":"application/vnd.github+json" }, cache:"no-store" });
    if(!res.ok) throw new Error(`Gist API ${res.status}`);
    const j = await res.json();
    const f = j.files?.["current.txt"];
    if (!f) throw new Error("Gistに current.txt がありません");
    if (f.truncated === false && typeof f.content === "string") return f.content.trim();
    if (f.raw_url) {
      const r = await fetch(f.raw_url + "?t=" + Date.now(), { cache:"no-store" });
      if(!r.ok) throw new Error(`Gist RAW ${r.status}`);
      return (await r.text()).trim();
    }
    throw new Error("Gistファイルを読めません（raw_urlなし）");
  }catch(e){
    const r = await fetch(RAW_GIST + "?t=" + Date.now(), { cache:"no-store" });
    if(!r.ok) throw new Error(`Gist RAW ${r.status} / ${e.message}`);
    return (await r.text()).trim();
  }
}

/* ---------- URL→id抽出＆プロキシURL生成 ---------- */
function buildApiUrlFromSource(u){
  const s=(u||"").trim();
  let m = s.match(/^https?:\/\/api\.whowatch\.tv\/lives\/(\d+)/);
  if(!m) m = s.match(/whowatch\.tv\/(?:lives|viewer)\/(\d+)/);
  if(!m) m = s.match(/r\.whowatch\.tv\/lives\/(\d+)/);
  if(!m) return null;
  const id = m[1];
  return { id, url: `${WORKER_BASE}${id}?last_updated_at=` };
}

/* ---------- 表示：最新を上に（先頭に追加） ---------- */
function prependComment(c){
  const li   = document.createElement('li');
  const user = c?.user?.name ?? c?.user_name ?? "匿名";
  const msg  = c?.message ?? c?.escaped_message ?? c?.text ?? c?.body ?? "";
  const ts   = typeof c?.posted_at === "number"
                ? new Date(c.posted_at).toLocaleString()
                : (c?.created_at || c?.updated_at || c?.time || "");

  const userDiv = document.createElement('div');
  userDiv.className = "user";
  userDiv.textContent = user;

  const msgDiv = document.createElement('div');
  msgDiv.className = "msg";
  msgDiv.appendChild(sanitizeMessageHTML(msg)); // 安全にHTML反映

  const metaDiv = document.createElement('div');
  metaDiv.className = "meta";
  metaDiv.textContent = ts;

  li.appendChild(userDiv);
  li.appendChild(msgDiv);
  li.appendChild(metaDiv);

  elList.insertBefore(li, elList.firstChild); // 先頭に追加＝最新が上
  // 件数制限（古い方＝末尾から削除）
  const MAX = 80;
  while (elList.childElementCount > MAX) elList.removeChild(elList.lastChild);
}

/* ---------- 増分取得ロジック（last_updated_at は UNIXミリ秒） ---------- */
let apiUrl = "", liveId = "";
let lastCurMs = null;   // ★ 常に「UNIXミリ秒」を保持
let etag   = null;      // 必要に応じて使う（不安定なら無効化してOK）
let seen   = new Set(); // 重複防止

function idOf(c){
  return c?.id ?? `${c?.user?.id||c?.user_id||"u"}-${c?.posted_at||c?.created_at||c?.updated_at||Math.random()}`;
}
function tsMs(c){
  if (typeof c?.posted_at === "number") return c.posted_at;
  const t = c?.created_at || c?.updated_at || c?.time;
  const ms = Date.parse(t);
  return Number.isNaN(ms) ? 0 : ms;
}

async function init(){
  const txt = await readGistText();
  const first = (txt.split(/\r?\n/).map(s=>s.trim()).find(Boolean)) || "";
  const built = buildApiUrlFromSource(first);
  if (!built) throw new Error("対応外URL: " + first);
  apiUrl   = built.url;
  liveId   = built.id;
  lastCurMs = null; // リセット＝最初から取得
}

async function pollOnce(){
  const url = apiUrl + encodeURIComponent(lastCurMs != null ? String(lastCurMs) : "");
  const headers = {"cache-control":"no-store"};
  if (etag) headers["If-None-Match"] = etag; // もし相性悪ければこの行と下の etag 行をコメントアウト

  const res = await fetch(url, { headers });
  if (res.status === 304) return;
  if (!res.ok) throw new Error(`WhoWatch ${res.status}`);

  etag = res.headers.get("etag") || etag;
  const json = await res.json();

  // コメント配列（comments / data / 自動探索）
  let arr = Array.isArray(json.comments) ? json.comments
          : Array.isArray(json.data)     ? json.data
          : null;
  if (!arr){
    const find = (obj, depth=0) => {
      if(depth>3 || !obj) return null;
      if(Array.isArray(obj)){
        const score = obj.slice(0,5).reduce((n,it)=> n + (it && (it.message||it.text||it.body) ? 1:0), 0);
        return score>=2 ? obj : null;
      }
      if(typeof obj === "object"){
        for(const k of Object.keys(obj)){ const f=find(obj[k], depth+1); if(f) return f; }
      }
      return null;
    };
    arr = find(json);
  }
  if (!Array.isArray(arr) || !arr.length) return;

  // 時系列でソート（古→新）。その順で先頭に挿入すると、最後に入った最新が一番上に来る
  arr.sort((a,b)=> tsMs(a) - tsMs(b));

  const newly = [];
  for (const c of arr){
    const id = idOf(c);
    if (seen.has(id)) continue;
    seen.add(id);
    newly.push(c);
  }
  for (const c of newly){ prependComment(c); }

  // カーソル更新（サーバ返却優先 → 無ければ最後のコメント時刻）
  let nextCurMs = null;
  if (json.last_updated_at != null){
    const n = Number(json.last_updated_at);
    if (!Number.isNaN(n)) nextCurMs = n;
  }
  if (nextCurMs == null && arr.length){
    nextCurMs = tsMs(arr[arr.length - 1]);
  }
  // 取りこぼし防止で 1ms 引く（include 境界対策）
  if (nextCurMs != null) lastCurMs = nextCurMs - 1;
}

async function loop(){
  while(true){
    try{ await pollOnce(); } catch(e){ /* 画面には出さない（必要なら console.error(e)）*/ }
    await new Promise(r=>setTimeout(r, POLL_MS));
  }
}

(async function main(){
  try{
    await init();
    await pollOnce();
    loop();
  }catch(e){
    // 初期化失敗時のみ開発者ツールで確認
    console.error("init error:", e);
  }
})();
</script>
</body>
</html>






